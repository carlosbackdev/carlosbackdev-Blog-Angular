[
  {
    "slug": "scancam",
    "title": "ScanCam Visi√≥n IA & OCR",
    "video": "https://player.vimeo.com/video/0000000000",
    "images": [ { "image": "/assets/images/project/scancam.jpg" }, { "image": "/assets/images/project/scancam.jpg" } ],
    "repository": "https://github.com/carlosbackdev/ScanCam",
    "link": "https://github.com/carlosbackdev/ScanCam",
    "descripcion": "ScanCam es una aplicaci√≥n de escaneo inteligente que combina visi√≥n por computador, OCR avanzado y procesamiento sem√°ntico para extraer, limpiar y estructurar informaci√≥n desde im√°genes o documentos capturados por la c√°mara.",
    "dos": ["Preprocesar im√°genes (deskew, binarizaci√≥n) antes de OCR","Segmentar por bloques para mejorar precisi√≥n","Normalizar fechas e importes en un formato consistente","Cachear modelos OCR en caliente para reducir latencia"],
    "donts": ["Aplicar OCR sobre imagen cruda sin limpieza","Mezclar idiomas sin whitelist configurada","Sobreescribir datos originales sin conservar copia","Ignorar m√©tricas de precisi√≥n por tipo de documento"],
    "tradeoffs": ["OpenCV + Tesseract vs Servicios cloud OCR: menor coste y control, pero m√°s mantenimiento","OCR multi-paso (bloques) aumenta precisi√≥n pero incrementa latencia","Normalizaci√≥n heur√≠stica r√°pida vs Modelo NLP avanzado: velocidad frente a contextualizaci√≥n"],
    "diferenciacion": ["Pipeline completo: visi√≥n ‚Üí OCR ‚Üí normalizaci√≥n sem√°ntica","M√©tricas y precisi√≥n desde el dise√±o","Trade-offs expl√≠citos documentados","Extensible a dominios verticales"],
  "explication": "#### üì∏ ScanCam: Escaneo Inteligente con Visi√≥n + IA + OCR\n\nScanCam convierte tu c√°mara en una herramienta profesional de extracci√≥n de datos. Captura facturas, tickets, documentos t√©cnicos o textos impresos y el sistema los procesa para entregarte informaci√≥n estructurada lista para integrar o analizar.\n\n---\n#### üöÄ ¬øQu√© hace?\n- Detecta autom√°ticamente bordes y corrige perspectiva.\n- Mejora nitidez (filtros adaptativos y binarizaci√≥n inteligente).\n- Aplica OCR multilenguaje (N√∫meros, Espa√±ol, Ingl√©s, etc.).\n- Limpia ruido (caracteres err√≥neos, s√≠mbolos no deseados).\n- Analiza sem√°nticamente el texto (fechas, importes, entidades clave).\n- Exporta resultados en JSON estructurado o texto plano.\n\n---\n#### üß† Flujo de Procesamiento\n1. Captura / Importaci√≥n de imagen.\n2. Preprocesado: correcci√≥n de perspectiva + filtros (desenfoque gaussiano ligero + umbral adaptativo).\n3. Detecci√≥n de contornos y segmentaci√≥n de regiones relevantes.\n4. OCR por bloques (layout awareness) para mejorar precisi√≥n.\n5. Post-procesado l√©xico y normalizaci√≥n (regex + heur√≠sticas).\n6. Extracci√≥n sem√°ntica (fechas, totales, etiquetas clave).\n7. Generaci√≥n de resultado estructurado.\n\n---\n#### üîç Ejemplo de Salida JSON\n```json\n{\n  \"factura\": {\n    \"proveedor\": \"Ejemplo S.L.\",\n    \"fecha\": \"2025-09-30\",\n    \"total\": 128.45,\n    \"moneda\": \"EUR\"\n  }\n}\n```\n\n---\n#### üõ†Ô∏è Stack T√©cnico\n- Visi√≥n: OpenCV / filtros morfol√≥gicos / detecci√≥n de contornos.\n- OCR: Tesseract (optimizaci√≥n de whitelist + configuraci√≥n multilenguaje).\n- Backend / API: Spring Boot para exponer procesamiento batch o por streaming.\n- Frontend / Cliente: Angular (captura, preview, recorte interactivo).\n- IA Sem√°ntica: Reglas + posible integraci√≥n futura con modelos NLP ligeros.\n\n---\n#### ‚ú® Valor A√±adido\n- Reduce tareas manuales de transcripci√≥n.\n- Mejora precisi√≥n frente a OCR directo sin preprocesamiento.\n- Extensible para dominios espec√≠ficos: log√≠stica, finanzas, inventario.\n\n---\n#### üß™ Calidad y Rendimiento\n- Cach√© de modelos cargados en memoria.\n- Procesamiento en lotes para m√∫ltiples p√°ginas.\n- Normalizaci√≥n configurable por tipo de documento.\n\n---\n#### üîÆ Futuras Mejoras\n- Entrenamiento ligero de reconocimiento de campos espec√≠ficos.\n- Firma digital/verificaci√≥n de autenticidad.\n- Modo offline optimizado.\n\n---\n#### üîó Integraci√≥n\nPuede actuar como servicio independiente (microservicio OCR) o embebido en aplicaciones empresariales. Ideal para automatizar flujos documentales.\n\n---\n#### ‚úÖ Resultado\nUn pipeline robusto de captura ‚Üí limpieza ‚Üí OCR ‚Üí estructuraci√≥n sem√°ntica listo para integrarse en dashboards, ERPs o sistemas de an√°lisis documental.",
    "id": 6,
    "metrics": [
      { "name": "OCR Accuracy", "current": "93%", "target": ">95%", "description": "Precisi√≥n promedio en facturas y tickets procesados" },
      { "name": "Latency p95", "current": "2.4s", "target": "<3s", "description": "Tiempo captura‚ÜíJSON para im√°genes de 1 p√°gina" },
      { "name": "Throughput", "current": "18 img/min", "target": "25 img/min" }
    ],
    "tecnology": [
      { "name": "Flink", "image": "/assets/images/logo/flink.png" },
      { "name": "Docker", "image": "/assets/images/logo/docker.svg" },
      { "name": "Spring Boot", "image": "/assets/images/logo/spring.png" },
      { "name": "Kafka", "image": "/assets/images/logo/kafka.png" },
      { "name": "Java", "image": "/assets/images/logo/java.png" }
    ]
  },
  {
    "slug": "streaming-gestamp",
    "title": "Plataforma Streaming Industrial (Gestamp)",
    "video": "",
    "images": [ { "image": "/assets/images/project/gestamp.png" } ],
    "repository": "#",
    "link": "#",
    "descripcion": "Plataforma de streaming industrial para ingesta IoT (sensores, PLCs, l√≠neas) con orden parcial, replay, contratos versionados y observabilidad integral (lag, throughput, latencia end‚Äëto‚Äëend).",
    "dos": ["Definir contratos versionados Avro/Protobuf","Monitorizar lag y throughput por t√≥pico","Ajustar paralelismo seg√∫n backpressure","Operadores de enriquecimiento reutilizables"],
    "donts": ["Consumir sin validar esquema","Un solo consumer-group para todo","Ignorar claves de particionado sem√°ntico","Mezclar dominios en un topic"],
    "tradeoffs": ["Kafka vs Redis Streams: persistencia y replay vs menor latencia","Flink vs Spark: true streaming vs ecosistema batch unificado","Schema Registry a√±ade complejidad pero evita drift"],
    "diferenciacion": ["Caso real industrial, no toy","Gobernanza de t√≥picos y esquemas","Observabilidad desde el inicio","Dominios y operadores desacoplados"],
  "explication": "## Plataforma Streaming Industrial\n\n### üéØ Objetivo Estrat√©gico\nUnificar la ingesta y procesamiento continuo de se√±ales industriales (temperatura, vibraciones, consumo energ√©tico, estados de PLC, contadores de producci√≥n) para generar KPIs casi en tiempo real, habilitar anal√≠tica operativa y preparar terreno para mantenimiento predictivo y optimizaci√≥n energ√©tica.\n\n### üß± Arquitectura L√≥gica (Vista Macro)\n| Capa | Funci√≥n | Tecnolog√≠as | Notas |\n|------|---------|-------------|-------|\n| Edge / Gateway | Normalizaci√≥n m√≠nima (timestamp, unidad f√≠sica, UUID) | Dispositivos / Scripts | Evitar l√≥gica pesada en edge para facilitar upgrades |\n| Ingesta | Log distribuido ordenado por partici√≥n | Kafka | Particionado sem√°ntico por dominio (energ√≠a, calidad, mantenimiento) |\n| Contratos | Validaci√≥n, versionado y compatibilidad | Schema Registry (Avro) | Estrategia backward compatible + auditor√≠a |\n| Procesamiento | Enriquecimiento, agregaci√≥n, detecci√≥n anomal√≠as | Flink | Ventanas tumbling/sliding + state backend RocksDB |\n| Persistencia Operacional | KPIs materializados y estados intermedios | Flink State + (Redis opcional) | Minimiza consultas repetidas downstream |\n| Almac√©n Anal√≠tico | Historizaci√≥n para BI / ML | Parquet / Lake | Particionado por fecha y dominio, compaction programada |\n| Exposici√≥n | APIs, dashboards, alertas | Spring Boot + Grafana + Prometheus | SLA, m√©tricas, eventos derivados |\n\n### üîå Contratos y Modelos de Evento\n- Esquemas Avro versionados: `sensor-reading`, `machine-state`, `energy-usage`, `quality-flag`.\n- Campos base obligatorios: `event_id`, `source_id`, `ts_event`, `ingest_ts`, `domain`, `value`, `unit`, `quality`.\n- Evoluci√≥n con reglas: s√≥lo campos opcionales nuevos + no eliminar ni cambiar tipo.\n- Validaci√≥n previa a publicaci√≥n (producer wrapper) ‚Üí reducci√≥n de drift.\n\n### üîÑ Flujo de Procesamiento (Detalle)\n1. Edge publica eventos normalizados a t√≥picos de dominio.\n2. Flink Source consume con watermarking basado en `ts_event` (lateness tolerada 90s).\n3. Operador de parsing + validaci√≥n (rechaza eventos corruptos ‚Üí DLQ).\n4. Enriquecimiento (join cat√°logos: m√°quina, l√≠nea, planta).\n5. Agregaciones multi-ventana (1m, 5m, 1h).\n6. Detecci√≥n de anomal√≠as estad√≠stica (z-score din√°mico y percentiles adaptativos).\n7. Materializaci√≥n de KPIs (energ√≠a, OEE parcial, ratio defectos).\n8. Sinks: almacenamiento hist√≥rico + topic de KPIs + API cache.\n\n### ‚ôªÔ∏è Resiliencia y Fiabilidad\n- Checkpoints incrementales cada 60s + retenci√≥n 24h.\n- `exactly-once` para sinks de KPIs cr√≠ticos.\n- Estrategia de reprocess: reprocesar s√≥lo ventanas afectadas (marcadores de rango).\n- Alerta proactiva: si lag > 2k msgs/partici√≥n o watermark delay > 120s.\n\n### ‚öñÔ∏è Principales Trade-offs (Ampliados)\n| Decisi√≥n | Alternativa | Motivo | Trade-off |\n|----------|------------|--------|-----------|\n| Kafka + Flink | Spark Streaming | Latencia y true streaming | Menor ecosistema batch integrado |\n| Avro + Registry | JSON libre | Esquemas fuertes + compatibilidad | Overhead inicial de definici√≥n |\n| Ventanas multi-tier | S√≥lo raw | KPIs listos r√°pido | Coste en memoria state backend |\n| Enriquecimiento en streaming | Post-proceso batch | KPIs consistentes al vuelo | Mayor complejidad operativa |\n| RocksDB state backend | In-memory | Escalabilidad y tolerancia a fallos | Latencia ligeramente mayor |\n\n### üîê Seguridad / Gobernanza\n- RBAC por dominio y tipo de evento.\n- Encriptaci√≥n en tr√°nsito (TLS) y opcional en reposo (at-rest).\n- Auditor√≠a: qui√©n publica nuevos esquemas y cu√°ndo.\n- Topic naming convention: `dominio.tipo.version`.\n\n### üìä M√©tricas Operacionales (Observabilidad)\n| M√©trica | Actual | Objetivo | Uso |\n|---------|--------|----------|-----|\n| Latencia E2E p95 | 6.5s | <8s | SLA usuario final |\n| Lag m√°x partici√≥n | 1.2k | <2k | Capacidad / backpressure |\n| Uptime ingesta | 99.4% | >99.5% | Fiabilidad |\n| Backpressure ratio | <5% | <10% | Salud pipeline |\n| Reprocesos/d√≠a | <3 | <5 | Estabilidad de datos |\n\n### üß™ Calidad de Datos\n- Validaciones de rango: temperatura, vibraci√≥n, consumo.\n- Monoton√≠a en contadores incrementales.\n- Unidad estandarizada (evita mezcla ¬∞C / K).\n- DLQ con dashboard de volumen y causa (parsing, esquema, rango).\n- M√©trica derivada: % eventos descartados < 0.5%.\n\n### üö® Anomal√≠as y Alertas\n- Detecci√≥n z-score din√°mico (ajuste seg√∫n ventana hist√≥rica m√≥vil).\n- Percentiles adaptativos (P10/P90) para se√±ales ruidosas.\n- Alertas multi-criterio (lag + latencia + ratio anomal√≠as).\n\n### üõ£Ô∏è Roadmap Evolutivo\nFase | Enfoque | Objetivo Valor |\n-----|---------|----------------|\n1 | Base estable (actual) | KPIs confiables y trazables |\n2 | Mantenimiento predictivo (modelos ligeros) | Reducir downtime |\n3 | Optimizaci√≥n energ√©tica | Disminuir consumo pico |\n4 | Expansi√≥n multi-planta | Escalar gobernanza y cat√°logo |\n\n### üß© Extensibilidad\n- Operadores Flink desacoplados y reutilizables (enriquecimiento, filtrado, outlier).\n- Facilidad para enchufar nuevos dominios (a√±adir esquema + topic + job).\n- Cat√°logo t√©cnico auto-generado (esquemas + descripci√≥n + KPIs).\n\n### ‚úÖ Resultados Tangibles\n- Latencia dentro de SLA p95.\n- Lag estable y controlado bajo carga pico.\n- KPIs energ√©ticos y de calidad disponibles en dashboards sin procesos nocturnos.\n- Base preparada para introducir ML sin rehacer cimientos.\n\n### üîÆ Pr√≥ximos Experimentos\n- Feature flags para modelos de predicci√≥n temprana.\n- Estrategia de compaction avanzada para t√≥picos de referencia lenta-mutaci√≥n.\n- Integraci√≥n con sistema de tickets para incidentes autom√°ticos.\n\n---\n**Resumen**: Una plataforma de streaming industrial modular, observable, gobernada y preparada para escalar tanto en volumen como en complejidad anal√≠tica sin sacrificar trazabilidad ni calidad de datos.",
    "id": 7,
    "metrics": [
      { "name": "End-to-End Latency p95", "current": "6.5s", "target": "<8s" },
      { "name": "Ingestion Uptime", "current": "99.4%", "target": ">99.5%" },
      { "name": "Partition Lag Max", "current": "1.2k msgs", "target": "<2k msgs" },
      { "name": "Backpressure Ratio", "current": "<5%", "target": "<10%", "description": "Tiempo en backpressure sobre tiempo total operator" }
    ],
    "tecnology": [
      { "name": "Kafka", "image": "/assets/images/logo/kafka.png" },
      { "name": "Flink", "image": "/assets/images/logo/flink.png" },
      { "name": "Spring Boot", "image": "/assets/images/logo/spring.png" },
      { "name": "Docker", "image": "/assets/images/logo/docker.svg" }
    ]
  },
  {
    "slug": "powerroutine-app",
    "title": "PowerRoutine App",
    "video":"https://player.vimeo.com/video/1088705172?badge=0&autopause=0&player_id=0&app_id=58479",
    "images": [
      {
        "image": "assets/images/project/powerroutine.png"
      },
      {
        "image": "assets/images/project/powerroutine.png"
      }
    ],
    "repository": "https://github.com/carlosbackdev/PowerRoutine-App",
    "link": "https://github.com/carlosbackdev/PowerRoutine-App",
    "descripcion": "PowerRoutine es una aplicaci√≥n Android desarrollada en Java que te ayuda a crear, personalizar y hacer seguimiento de tus rutinas de entrenamiento de forma inteligente y adaptada a tu perfil.",
    "explication": "#### üöÄ ¬øPara qu√© sirve PowerRoutine?\nPowerRoutine est√° dise√±ada para personas que desean mejorar su entrenamiento con rutinas personalizadas y seguimiento de progreso. Permite:\n- Registrar tus preferencias y caracter√≠sticas personales (objetivo, nivel, d√≠as disponibles, etc.).\n- Recibir recomendaciones autom√°ticas de rutinas de entrenamiento adaptadas a tu perfil.\n- Seleccionar las rutinas que m√°s te gusten, y despu√©s elegir los ejercicios que vas a realizar en cada una.\n- Consultar los detalles de cada ejercicio: series, repeticiones, descanso, material, t√©cnica, m√∫sculo implicado, etc.\n- Marcar ejercicios y rutinas como completadas y hacer seguimiento semanal de tu avance.\n- Modificar tus preferencias y rutinas cuando quieras.\nTodo el flujo est√° enfocado en la personalizaci√≥n y el seguimiento estructurado del progreso.\n---\n#### üèóÔ∏è Arquitectura de la Aplicaci√≥n\n##### Android App (Java + MVVM)\n- **Lenguaje principal**: Java (todas las Activities y l√≥gica central est√°n en Java).\n- **Patr√≥n MVVM**: Separaci√≥n clara entre Model (datos y l√≥gica), View (interfaces), y ViewModel (gesti√≥n de estados y l√≥gica de presentaci√≥n).\n###### Componentes principales:\n- **UserPreferences**: Gestiona las preferencias del usuario (nivel, objetivo, d√≠as, etc.) y calcula repeticiones, descansos, etc.\n- **Activities principales**:\n  - `PerfilActivity`: Edici√≥n de perfil y preferencias.\n  - `RutineSelecetedActivity` y `EjercicesSelectedActivity`: Selecci√≥n de rutinas y ejercicios.\n  - `EjerciceDetailsActivity`: Consulta y registro de detalles de cada ejercicio.\n  - `CalendarActivity`: Seguimiento semanal de rutinas completadas.\n- **Persistencia y sincronizaci√≥n**: Conexi√≥n al backend mediante Retrofit y comunicaci√≥n con una API RESTful.\n- **Temas y personalizaci√≥n**: Opciones claro/oscuro mediante preferencias y componentes reutilizables.\n---\n##### Flujo t√≠pico de usuario\n1. **Registro de preferencias**: El usuario define objetivo, nivel, d√≠as de entrenamiento, etc.\n2. **Selecci√≥n de rutinas**: La app recomienda rutinas y el usuario escoge cu√°les seguir.\n3. **Elecci√≥n de ejercicios**: Dentro de cada rutina, el usuario selecciona los ejercicios disponibles y los guarda.\n4. **Seguimiento**: Al realizar los ejercicios, puede marcar series/repeticiones y completar rutinas.\n5. **Visualizaci√≥n de progreso**: `Calendar` y perfil muestran rutinas completadas y detalles de avance.\n---\n##### üõ†Ô∏è Backend: Spring Boot + PostgreSQL\n- **API RESTful**: Desarrollada con Spring Boot, arquitectura en capas (Controlador, Servicio, Repositorio, DTOs).\n- **Base de datos relacional**: PostgreSQL almacena usuarios, rutinas, ejercicios, m√∫sculos, objetivos, niveles y registros de progreso.\n##### Personalizaci√≥n avanzada:\n- Las rutinas se generan seg√∫n los par√°metros del usuario.\n- Cambios en nivel u objetivo modifican autom√°ticamente series, repeticiones y ejercicios sugeridos.\n- Algoritmo para evitar rutinas incompatibles muscularmente en el mismo periodo.\n- **Sin registro obligatorio**: Puedes explorar rutinas sin necesidad de crear cuenta.\n---\n##### Ejemplo de flujo backend\n1. **Android (Cliente)**\n   ‚¨áÔ∏è\n2. **Controlador REST (Spring Boot)**\n   ‚¨áÔ∏è\n3. **Servicio (Java)**\n   ‚¨áÔ∏è\n4. **Repositorio (JPA/Hibernate)**\n   ‚¨áÔ∏è\n5. **Base de datos (PostgreSQL)**\n   ‚¨ÜÔ∏è\n6. **DTOs y JSON para Android**\n---\n##### üìä Caracter√≠sticas T√©cnicas\n- **Lenguaje**: Java (Android, Spring Boot)\n- **Arquitectura**: MVVM (frontend), Clean/Layered (backend)\n- **Persistencia**: PostgreSQL\n- **Comunicaci√≥n**: Retrofit para llamadas HTTP\n- **Gesti√≥n de estado**: Preferencias de usuario, seguimiento de rutinas completadas, cambio de tema, etc.\n- **UI**: Activities y componentes reutilizables (Views, Navigators, etc.)\n---\n##### ‚ú® ¬øPor qu√© usar PowerRoutine?\n- **Personalizaci√≥n total**: No hay dos usuarios iguales, y tus rutinas tampoco lo ser√°n.\n- **Seguimiento f√°cil**: Marca tus avances y consulta tu progreso semanal.\n- **Escalable y mantenible**: Arquitectura profesional tanto en app como backend, pensado para crecer.\n- **Experiencia de usuario**: Interfaz intuitiva, cambios de tema y navegaci√≥n fluida.\n- **Open Source**: Insp√≠rate o contribuye en el desarrollo.",
    "id":4,
    "tecnology": [
      {
        "name": "Java",
        "image":"/assets/images/logo/java.png"
      },
      {
        "name": "MySQL",
        "image":"/assets/images/logo/mysql.png"
      },
      {
        "name": "Android Studio",
        "image":"/assets/images/logo/android.png"
      },
      {
        "name": "Spring Boot",
        "image":"/assets/images/logo/spring.png"
      },{
        "name": "IA Integration",
        "image":"/assets/images/logo/ia.webp"
      }
    ]
  },
    {
      "slug": "moviesearch",
      "title": "MovieSearch Aplicaci√≥n Web",
      "video":"https://player.vimeo.com/video/1065072327?badge=0&autopause=0&player_id=0&app_id=58479",
      "images": [
        {
          "image": "/assets/images/project/moviesearch.webp"
        },
        {
          "image": "/assets/images/project/capturaMovieSearch.webp"
        }
      ],
      "repository": "https://github.com/carlosbackdev/MoviSearch",
      "link": "https://moviesearch.es",
      "descripcion": "Una aplicaci√≥n de recomendaciones de pel√≠culas que integra inteligencia artificial y procesamiento de lenguaje natural para ofrecer sugerencias personalizadas seg√∫n las preferencias del usuario. A trav√©s de un servicio inteligente, la app analiza consultas en lenguaje natural y proporciona recomendaciones.",
      "explication": "#### API Spring Boot IA para B√∫squeda de Pel√≠culas y Chatbot ü§ñ\n\nEsta API es la columna vertebral de la plataforma, habilitando caracter√≠sticas avanzadas como b√∫squedas de pel√≠culas por frases, interacciones con un chatbot y gesti√≥n de datos de usuarios. Se integra con m√∫ltiples APIs externas, como OpenAI, Google Translate, TMDB, Firebase y Datamuse, para ofrecer una experiencia de usuario fluida e inteligente. Esta es la parte backend del proyecto MovieSearch App Angular.\n\n---\n\n##### Tecnolog√≠as Usadas üõ†Ô∏è\n- **Spring Boot**: Framework principal para construir la API. üü¢\n- **Java**: Lenguaje de programaci√≥n utilizado en la API. üî¥\n- **MySQL**: Base de datos para almacenar datos de usuarios e interacciones. üê¨\n- **JWT**: Para seguridad, la API usa tokens para autenticaci√≥n. üßë‚Äçü¶±\n- **OpenAI API**: Para el chatbot y tareas avanzadas de procesamiento de lenguaje natural (NLP). üß†\n- **Google Translate API**: Para soporte multiling√ºe. ‚úçÔ∏è\n- **TMDB API**: Para obtener datos sobre pel√≠culas y series. üé•\n- **Datamuse API**: Para mejorar las capacidades de b√∫squeda. üìò\n- **Firebase**: Para autenticaci√≥n y actualizaciones en tiempo real. üî•\n\n---\n\n##### Caracter√≠sticas Principales üåü\n\n1. **B√∫squeda de Pel√≠culas por Frases üé•**\n   - **Procesamiento de Lenguaje Natural (NLP)**: Analiza las frases de los usuarios utilizando herramientas de IA.\n   - **Integraci√≥n con TMDB**: Busca en la base de datos TMDB para encontrar pel√≠culas relevantes seg√∫n las frases procesadas.\n   - **B√∫squeda Avanzada**: Maneja consultas complejas y devuelve informaci√≥n detallada sobre las pel√≠culas (descripci√≥n, elenco, calificaciones, etc.).\n\n2. **Integraci√≥n con Chatbot de OpenAI ü§ñ**\n   - **OpenAI API**: Potencia un chatbot conversacional que puede responder preguntas de los usuarios, recomendar pel√≠culas y asistir con las b√∫squedas.\n   - **Respuestas Din√°micas**: Genera respuestas humanas usando los modelos GPT de OpenAI.\n   - **Traducci√≥n de Idiomas**: Utiliza Google Translate API para soportar interacciones multiling√ºes.\n\n3. **Gesti√≥n de Usuarios üë§**\n   - **Base de Datos MySQL**: Almacena los datos de los usuarios, como:\n      - Detalles de registro.\n      - Pel√≠culas y series guardadas.\n      - Listas personalizadas.\n      - Comentarios y valoraciones.\n      - Historial de b√∫squedas.\n   - **Experiencia Personalizada**: Los usuarios pueden crear listas, guardar pel√≠culas y compartir sus colecciones.\n\n4. **Preparaci√≥n para Machine Learning üß†**\n   - **Recopilaci√≥n de Datos**: Todas las interacciones, b√∫squedas y preferencias de los usuarios se almacenan para futuros modelos de machine learning.\n   - **An√°lisis**: Permite obtener conocimientos sobre el comportamiento y preferencias de los usuarios para recomendaciones personalizadas.\n\n5. **Integraci√≥n con M√∫ltiples APIs üîó**\n   - **TMDB API**: Obtiene datos sobre pel√≠culas y series.\n   - **OpenAI API**: Maneja interacciones del chatbot y tareas complejas de NLP.\n   - **Google Translate API**: Soporta consultas y respuestas multiling√ºes.\n   - **Datamuse API**: Mejora las capacidades de b√∫squeda con sugerencias de sin√≥nimos y frases.\n   - **Firebase**: Gestiona la autenticaci√≥n y actualizaciones en tiempo real.\n\n---\n\n##### C√≥mo Funciona ‚öôÔ∏è\n1. **Entrada del Usuario ‚¨ÖÔ∏è**\n   - El usuario ingresa una frase o consulta (por ejemplo, 'Encuentra una pel√≠cula sobre aventuras espaciales').\n\n2. **Procesamiento de la Frase üìò**\n   - La API utiliza OpenAI y Google Translate para analizar y procesar la frase.\n   - Las tareas complejas de NLP son manejadas por OpenAI, mientras que la traducci√≥n de idioma es gestionada por Google Translate.\n\n3. **B√∫squeda de Pel√≠culas üé•**\n   - La consulta procesada se env√≠a a la API TMDB para obtener las pel√≠culas relevantes.\n   - Los resultados son filtrados y devueltos al usuario con informaci√≥n detallada.\n\n4. **Interacci√≥n con el Chatbot üóÉÔ∏è**\n   - El chatbot, alimentado por OpenAI, interact√∫a con el usuario para proporcionar informaci√≥n adicional, recomendaciones o asistencia.\n\n5. **Almacenamiento de Datos üê¨**\n   - Todos los datos del usuario, incluidas las b√∫squedas, pel√≠culas guardadas, listas y comentarios, se almacenan en la base de datos MySQL.\n   - El historial de b√∫squedas y las interacciones se registran para su an√°lisis futuro en modelos de machine learning.\n\n---\n\n#### Aplicaci√≥n Web y Android de MovieSearch IA üçø\nLa aplicaci√≥n MovieSearch permite a los usuarios buscar pel√≠culas a trav√©s de frases y disfrutar de una experiencia fluida, con una interfaz intuitiva, gracias al uso de tecnolog√≠as modernas en el frontend. Los usuarios pueden interactuar con el chatbot, guardar pel√≠culas en listas y compartirlas.\n\n##### Tecnolog√≠as Usadas en el Frontend üõ†Ô∏è\n- **Angular**: Framework principal para la construcci√≥n de la aplicaci√≥n web. üîÑ\n- **TypeScript**: Lenguaje de programaci√≥n para desarrollar la l√≥gica de la aplicaci√≥n. üü°\n- **HTML**: Estructura b√°sica de la p√°gina web. üåê\n- **CSS/SCSS**: Estilos para la presentaci√≥n visual y dise√±o responsivo. üé®\n- **Firebase**: Para la autenticaci√≥n de usuarios con Google. üî•\n- **Capacitor**: Para convertir la aplicaci√≥n Angular en una app Android. üé®\n\n---\n\n##### Composici√≥n del Proyecto üöÄ\n- **Backend**: Spring Boot con herramientas de IA y NLP. üìä\n- **Base de Datos**: MySQL (Para informaci√≥n de usuarios, listas... y machine learning) y TMDB para datos de pel√≠culas. üíæ\n- **Frontend**: Tecnolog√≠as modernas de Angular 19 para una experiencia de usuario fluida. üåê\n- **Firebase**: Para iniciar sesi√≥n con Google. üî•\n- **Capacitor**: Para desplegar el proyecto Angular como una aplicaci√≥n Android. üé®",
      "id":1,
      "tecnology": [
        {
          "name": "Java",
          "image":"/assets/images/logo/java.png"
        },
        {
          "name": "MySQL",
          "image":"/assets/images/logo/mysql.png"
        },
        {
          "name": "Angular",
          "image":"/assets/images/logo/angular.png"
        },
        {
          "name": "Spring Boot",
          "image":"/assets/images/logo/spring.png"
        },{
          "name": "IA Integration",
          "image":"/assets/images/logo/ia.webp"
        }
      ]
    },
    {
      "slug": "chatsocket",
      "title": "ChatSocket Chat Client y Server",
      "video":"/assets/images/project/chatsocket.webp",
      "images": [
        {
          "image": "/assets/images/project/chatsocket.webp"
        },
        {
          "image": "/assets/images/project/socketjava.png"
        }
      ],
      "repository": "https://github.com/carlosbackdev/ChatSockets",
      "link": "https://github.com/carlosbackdev/ChatSockets",
      "explication": "#### üí¨ ChatSockets üîó\n\n #ChatSockets es una aplicaci√≥n de chat cliente-servidor basada en Java que utiliza sockets, multi-threading y el patr√≥n Observer para comunicaci√≥n en tiempo real. Creada por **carlosbackdev**.\n---\n##### üìö Fundamentos Te√≥ricos\n1. **Arquitectura Cliente/Servidor** üñ•Ô∏è‚ÜîÔ∏èüñ•Ô∏è\n   - **Servidor**: Proporciona servicios, siempre escuchando solicitudes de los clientes.\n   - **Cliente**: Se conecta al servidor, env√≠a/recibe mensajes.\n   - ‚û°Ô∏è M√∫ltiples clientes pueden conectarse simult√°neamente al servidor, que gestiona la comunicaci√≥n y los recursos.\n2. **Comunicaci√≥n por Sockets y Patr√≥n Observer en Java** üß©üì°\n   - **Sockets**: Permiten comunicaci√≥n directa entre aplicaciones en una red.\n   - **Patr√≥n Observer**: Usado con `MensajeListener` y `MensajesEscucha` para desacoplar eventos de red de la l√≥gica de la interfaz gr√°fica y actualizar autom√°ticamente la UI al recibir mensajes.\n3. **Multi-threading para Comunicaci√≥n en Tiempo Real** üßµ‚ö°\n   - El servidor crea un hilo dedicado por cliente para comunicaci√≥n as√≠ncrona.\n   - Los clientes escuchan mensajes del servidor en un hilo separado, manteniendo la UI responsiva.\n---\n##### üöÄ Caracter√≠sticas\n- ü§ñ Interfaz gr√°fica intuitiva con JavaFX para cliente y servidor.\n- üîÅ Soporte para m√∫ltiples clientes simult√°neos.\n- üì¢ Mensajes de difusi√≥n del servidor a todos los clientes.\n- üì° Comunicaci√≥n en tiempo real y actualizaciones de conexi√≥n.\n- üìù Registro en consola de eventos clave.\n- üíæ JAR ejecutable para despliegue multiplataforma.\n- üßº C√≥digo modular, limpio y escalable.\n---\n##### üõ†Ô∏è Tecnolog√≠as Usadas\n- ‚úÖ **Java 17**\n- üé® **JavaFX 17**\n- ‚öôÔ∏è **Maven**\n- üåê **TCP Sockets**\n- üß† **Threads & ExecutorService**\n- üì∂ **Patr√≥n Observer**\n- üìÑ **FXML**\n---\n##### üåê Consejos de Red\n- Configura la VM de Linux en modo puente o NAT con reenv√≠o de puertos.\n- Haz ping a la IP de Linux desde Windows para confirmar conectividad.\n- Usa la IP de Linux (por ejemplo, `10.0.3.32`) y el puerto configurado al iniciar el cliente.\n- Lanza m√∫ltiples instancias de cliente para probar el chat grupal.",
      "id":5,
      "tecnology": [
        { "name": "Java", "image":"/assets/images/logo/java.png" },
        { "name": "Windows Server", "image":"/assets/images/logo/windows.webp" },
        { "name": "Linux", "image":"/assets/images/logo/ubuntu.webp" }
      ]
    },
    {
      "slug": "elecidea-web",
      "title": "ElecIdea API  & App Web",
      "video":"https://player.vimeo.com/video/1065067394?badge=0&autopause=0&player_id=0&app_id=58479",
      "images": [
        {
          "image": "/assets/images/project/elecideaWeb.webp"
        },
        {
          "image": "/assets/images/project/capturaElecIdea.webp"
        }
      ],
      "repository": "https://github.com/carlosbackdev/ElecIdea-Web-App",
      "link": "https://www.elecidea.com",
      "descripcion": "Elecidea es una soluci√≥n empresarial integral para el sector el√©ctrico, que incluye una API RESTful construida con Spring Boot, un frontend en JavaScript y una base de datos MySQL alojada en Google Cloud. El sistema utiliza una arquitectura basada en microservicios con contenedores Docker y despliegue continuo, optimizando la escalabilidad, mantenimiento y eficiencia operativa.",
      "explication": "#### Aplicaci√≥n Web ElecIdea\n\nBienvenido a ElecIdea, una aplicaci√≥n web para gestionar clientes e invoices el√©ctricas. Hereda las funcionalidades de la aplicaci√≥n Elecidea y ofrece las siguientes caracter√≠sticas:\n\n##### Caracter√≠sticas Principales:\n- üì≤ **Descarga la app**\n- üë• **Reg√≠strate como usuario**\n- üíæ **Gestiona tus datos**\n- üìë **Visualiza clientes, facturas y proyectos**\n- üìä **Realiza seguimiento de las finanzas de tu empresa**\n\nLa web est√° alojada en Netlify y se comunica con la API REST de Elecidea, desarrollada con **Spring Boot**.\n\n---\n\n##### Tecnolog√≠as Principales:\n- **Spring Boot**: Framework robusto para el desarrollo de la API backend üöÄ\n- **Java**: Lenguaje de programaci√≥n para la API ‚òï\n- **MySQL**: Base de datos alojada en Google Cloud SQL üóÑÔ∏è\n- **Docker**: Contenerizaci√≥n de la aplicaci√≥n üê≥\n- **Railway**: Plataforma de hosting para la imagen Docker üöÇ\n- **Google Cloud**: Plataforma de nube para el hosting de la base de datos ‚òÅÔ∏è\n\n---\n\n#### Parte Web (Frontend):\n- **HTML**: Estructura las p√°ginas web para una experiencia interactiva y accesible üåê\n- **CSS**: Define los estilos y el dise√±o visual de la p√°gina, optimizando la apariencia üé®\n- **JavaScript**: Conecta el frontend con el backend, maneja las interacciones de usuario y permite la creaci√≥n de animaciones y efectos din√°micos üîÑ\n\n##### Caracter√≠sticas Clave:\n- üìë **Gestiona datos de clientes e invoices**\n- üìù **Soporta registro de nuevos usuarios**\n- üíæ **Permite la gesti√≥n y visualizaci√≥n de datos**\n- üìä **Realiza seguimiento de invoices, clientes y proyectos**\n- üìà **Monitorea las finanzas de la empresa**\n\n##### Arquitectura:\nLa aplicaci√≥n est√° construida usando una arquitectura de microservicios RESTful, que incluye:\n- **Controller**: Gestiona la interfaz REST con la l√≥gica de negocio en el servicio.\n- **Service**: Implementa la l√≥gica de negocio y act√∫a como intermediario entre el controller y el repository.\n- **Repository**: Maneja operaciones con las entidades y la interacci√≥n con las bases de datos.",
      "id":2,
      "tecnology": [
        {
          "name": "Spring Boot",
          "image":"/assets/images/logo/spring.png"
        },
        {
          "name": "Java",
          "image":"/assets/images/logo/java.png"

        },
        {
          "name": "Java Script",
          "image":"/assets/images/logo/javascript.png"
        },
        {
          "name": "MySQL",
          "image":"/assets/images/logo/mysql.png"
        },
        {
          "name": "Hibernate",
          "image":"/assets/images/logo/hibernate.png"
        },
        {
          "name": "Docker",
          "image":"/assets/images/logo/docker.svg"
        }
      ]
    },
    {
      "slug": "elecidea-desktop",
      "title": "ElecIdea software ERP desktop",
      "video":"https://player.vimeo.com/video/1065067394?badge=0&autopause=0&player_id=0&app_id=58479",
      "images": [
        {
          "image": "/assets/images/project/elecideaDesktop.webp"
        },
        {
          "image": "/assets/images/project/capturaElecideaDesktop.webp"
        }
      ],
      "repository": "https://github.com/carlosbackdev/ElecIdea-App-Desktop-Java",
      "link": "https://www.elecidea.com",
      "descripcion": "Aplicaci√≥n de escritorio desarrollada en Java y MySQL, dise√±ada espec√≠ficamente para gestionar funciones clave en el sector el√©ctrico. El sistema es una soluci√≥n CRUD, que permite una gesti√≥n eficiente de diversas operaciones empresariales.",
      "explication": "##### üåü Caracter√≠sticas Principales:\n- üí≥ **Gesti√≥n de Facturas**: Administra f√°cilmente las facturas de los clientes, visualiza el estado de los pagos y genera documentos de facturaci√≥n.\n- üßë‚Äçüíº **Gesti√≥n de Clientes**: Almacena y realiza un seguimiento de la informaci√≥n detallada de los clientes, facilitando la administraci√≥n de cada cuenta.\n- üèóÔ∏è **Gesti√≥n de Proyectos**: Monitorea y sigue el progreso de los proyectos en curso, incluyendo los aspectos financieros y las etapas de finalizaci√≥n.\n- ‚öôÔ∏è **Automatizaci√≥n de Facturas**: Exporta autom√°ticamente las facturas en formato Excel y env√≠alas por correo electr√≥nico a los clientes, optimizando el proceso de facturaci√≥n.\n- üìà **Seguimiento del Crecimiento Empresarial**: Realiza un seguimiento de la evoluci√≥n de los clientes y el crecimiento del negocio, facilitando la toma de decisiones estrat√©gicas.\n\n---\n\n##### üíª Tecnolog√≠as Utilizadas:\n- **Java** para el desarrollo central de la aplicaci√≥n.\n- **MySQL** para la gesti√≥n de la base de datos.\n- **Swing** para la interfaz gr√°fica de usuario (GUI).\n- **Flatlaf** para un dise√±o moderno de tema oscuro.\n- **Apache POI** para generar documentos en formato XLSX.\n- **JavaMail** para el env√≠o autom√°tico de correos electr√≥nicos.\n- **Java Ant** para la compilaci√≥n y construcci√≥n de la aplicaci√≥n.\n- **NetBeans** como entorno de desarrollo.\n\n---\n\n##### üõ†Ô∏è Utilidad:\nLa aplicaci√≥n est√° dise√±ada para agilizar los procesos empresariales en el sector el√©ctrico, ofreciendo una soluci√≥n integral para la facturaci√≥n, gesti√≥n de clientes y seguimiento de proyectos. El sistema permite una gesti√≥n de datos f√°cil y una comunicaci√≥n eficiente con los clientes, incluyendo el env√≠o autom√°tico de facturas.",
      "id":3,
      "tecnology": [
        { "name": "Java", "image":"/assets/images/logo/java.png" },
        {
          "name": "MySQL",
          "image":"/assets/images/logo/mysql.png"
        },
        {
          "name": "Apache",
          "image":"/assets/images/logo/apache.png"
        },
        {
          "name": "Net Beans",
          "image":"/assets/images/logo/netbeans.png"
        }
      ]
    }
  ]
  